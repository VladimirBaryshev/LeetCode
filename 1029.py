# https://leetcode.com/problems/two-city-scheduling/
# 1029. Two City Scheduling

'''
    June 9th interview #4

    Edge cases:
    len(costs) >= 1
    len(costs[i]) == 2
    each (j,k in costs[i]) belongs N
    len(costs) is even(2n)

    Algo ideas:
        - iter costs and count deltas
        - sort deltas
        - iter for most deltas to less deltas
        - pick less item from pair
        - preserve n-count for A and B

    Feedback
    edge кейсы определил, здорово что сам обратил внимание, что длина списка должна быть четной
    задача непростая, поэтому подсказал тебе направление. после этого ты очень четко расписал идею решения, написал основной код. Это хорошо. То есть даже несмотря на то что была подсказка, все равно хорошо, что ты сумел ей эффективно воспользоваться и выйти на реализацию идеи в коде.
    Задача - пример, что паттерны забываются (вспоминаем задачу про интервалы) - обычно когда дается список с вложенными начальными и конечными координатами, это часто на сортировку (будь то интервалы, стоимость поездки в города a/b, начало/окончание чего-то итд. Когда такое видишь, сразу думай про сортировку и про критерий сортировки (будь то дельта или первая/вторая координата) - это может помочь понять идею алгоритма
    Важно не путать сложность сортировки. она nlogn (а logn это про бинарный поиск, который используется на уже отсортированном массиве). Я уверен ты это понимаешь, просто прозвучало logn один раз, что может смутить интервьюера.
    A_sum, B_sum - не самые удачные имена переменных, поменяли на A_cap позже и стало ок
    Функция Sort и использование lambda в нем надо запомнить - оно часто встречается в задачках. Ожидается, что кандидат владеет этим. По моему опыту проведения собесов в яндексе кандидаты часто знают это наизусть. Поэтому лучше тут не спотыкаться.
    еще помогает в начале поразмышлять о нижней и верхней границы тайм комплексити - это тоже может помочь выйти на паттерн и решение. Тривиальное - квадратичное решение путем попарных сравнений всех элементов. Дальше - можно ли решить за O(n)? Кажется, что нет. Ни в один, ни в 2 прохода мы не гарантируем, что сравним все элементы и убедимся, что решение верное. Тогда мб что-то среднее между квадратом и линией? ага, nlogn - вижу nlogn - сразу думаю о сортировке и о том как ее применить

    Follow up:
    1) подумать как более элегантно решить задачу, чтобы уменьшить кол-во условий, которые надо проверять. объем кода тоже уменьшится. Это хороший пункт на понимание. Подумай какие свойства мы точно знаем, если отсортируем массив по дельтам и как это поможет облегчить решение задачи. Можем обсудить потом, пиши в тг если что.
    2) почитай решения на литкоде, там есть хорошие посты с пруфами, почему жадный алгоритм (с использованием сортировки) работает. Вот хороший пост, но заходи туда не сразу, а как еще сам подумаешь
    https://leetcode.com/problems/two-city-scheduling/solutions/667781/python-3-lines-o-n-log-n-with-sort-explained/
        
'''

costs_1 = [[10,20],[30,200],[400,50],[30,20]] #110


costs_2 = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]] #1859


costs_3 = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]] #3086




def twoCitySchedCost(costs: list[list[int]]) -> int:

    max_cap = len(costs)/2
    A_cap = 0
    B_cap = 0
    minimum_cost_to_fly = 0

    costs.sort(key=lambda x: abs((x[0] - x[1])), reverse=True)

    for a,b in costs:

        if (a < b) and (A_cap < max_cap):
            A_cap += 1
            minimum_cost_to_fly += a

        elif (a > b) and (B_cap < max_cap):
            B_cap += 1
            minimum_cost_to_fly += b
        
        else:
            if B_cap < max_cap:
                B_cap += 1
                minimum_cost_to_fly += b
            else:
                A_cap += 1
                minimum_cost_to_fly += a




    return minimum_cost_to_fly


print(twoCitySchedCost(costs_1))
print(twoCitySchedCost(costs_2))
print(twoCitySchedCost(costs_3))


